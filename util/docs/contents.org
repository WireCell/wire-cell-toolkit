#+title: Select contents of WireCellUtil

This document is a curated list of main features and code provided by
WireCellUtil.  It likely gets out of sync with reality on ground.  Other sources
of this info:

- grep or otherwise read the source is always the most reliable.
- peruse the LLM-generated https://deepwiki.com/WireCell/wire-cell-toolkit

* Meta info about WCT

- Version.h :: the version of WCT, as set at build time.
- BuildConfig.h :: this header is actually under =build/= and is generated by the build process and holds what build options are set.  Most "user" code will not need this.   

* Conventions

- Exceptions.h :: The set of WCT exceptions.  WCT code should only throw these.  Use =raise<T>("message")= for the most convenient way to throw. 
- Units.h :: The wire-cell system of units (aka CLHEP's).  ALL WCT C++, Jsonnet and Python MUST use this.


* Wrapper headers

We provide "wrapper headers" for various external packages.  These should almost
always be used instead of including "bare" headers from the package.  They are
in place to wrap the "bare" headers in directives to control compilation
warnings that would otherwise break the strict release build of WCT.

- Eigen.h :: general Eigen3 headers
- EigenFFT.h :: Eigen's DFT implementation
- Graph.h :: Boost Graph Library
- Fmt.h :: for libfmt (as provided by SPDLOG)  
- Span.h :: Boost span
- Spdlog.h :: SPDLOG, see also Logging.h
- Measurement.h :: wrapper for =boost::units::measurement=.
- MultiArray.h :: wrapper for Boost multi dimensional arrays.


* Basic utility functions

- Bits.h :: simple bit functions.
- String.h :: string operations.

* Toolkit serivces

- ConfigManager.h :: Handles configuration, used by =WireCell::Main=
- PluginManager.h :: Handle dynamic loading of WCT plugin libraries.
- Logging.h :: Interface to SPDLOG.  Use of "bare" =std::cout= or =std::cerr= is not allowed (okay during devel/debug).

* Data structures

- Binning.h :: provide simple ROOT-like histogram axis functions.
- BoundingBox.h :: smallest 3D rectangular bounds on a set of 3D vectors.
- Configuration.h :: a JSON object and functions to set/get values.
- CoordRegion.h :: model regions and bounds on a coordinate axis.  Used, eg for Xregion in the sim.
- N-ary tree :: NaryTree*.h implements a generic n-ary tree with extensions to
  receive notifications of tree changes and to add dynamic "facade" types to
  nodes.
- k-d tree :: NFKD.h and NFKDVec.h provide k-d tree with different performance and functionality tradeoffs.  KDTree.h also has an older interface.  All use nanoflann.hpp as the backend.

- point clouds :: A point cloud consists of a named arrays (PointCloudArray.h)
  collected in a dataset (PointCloudDataset.h).  A subset of arrays can be
  selected to form coordinates (PointCloudCoordinates.h). Point clouds can live
  on n-ary trees (PointTree.h, used heavily in clus/) and in a graph
  (PointGraph.h).
- Quantity.h :: A value with an error that knows arithmetic.
- Stats.h :: A home-grown class that keeps mean and RMS.
- TagRules.h :: tags are used in a few components and this abstracts how to select or transform them
- Flagged.h :: (apply-pointcloud branch) efficient representation of a set of Boolean yes/now "flags".

* Operations

WCT util has some advance algorithms


- LMN.h :: the LMN resampling method
- ray grid tiling :: this is an optimized re implementation of the algorithm that originally gave "Wire Cell" its name.  It has a basic =Coordinates= type for fast computation of wire geometry related values in RayGrid.h and RayTiling.h provides the 3D imaging primitives.  The "raygrid" algorithms have been re-implemented for C++ libtorch in spng/ and in PyTorch wire-cell-python.
- Rectangles.h :: a 2D interval tree.
- Ress.h :: L1 regularized optimization    


* File

- Persist.h :: JSON and Jsonnet file I/O.
- Stream.h :: wrapper around the vendored "custard" providing tar, zip, numpy file I/O


* Arrays and vectors

- Array.h :: defines Eigen3 types and provides some utility functions for 1D and 2D dense arrays.   See [Wrapper headers].

- Point.h :: provides 3D vectors with vector arithmetic and utility functions.  It defines a =Point= and a =Vector= typedef to the D3Vector.  Though they are the same type, a =Point= is intended to be an absolute position in space while a =Vector= is for a relative displacement.  This also defines a =Ray= type that is used to define a 3D line segment.

- D2Vector.h :: 2D version of 3D vectors
- Waveform.h :: Functions to operate on "waveforms" represented as =std::vector+

* Testing

- doctest.h :: Include this when providing a =test/doctest_*.cxx=.  And, do provide these!
- Testing.h :: Some functions providing some services that a full WCT app takes for granted.
- *Testing.h :: Various "topics" have special support for writing tests.
- MemUsage.h :: Get the current memory usage of the process and produce a report.
- TimeKeeper.h :: A "stop watch" to time segments of code and produce a report.
- ExecMon.h :: Combo of MemUsage and TimeKeeper.


* 

Bee.h
BufferedHistogram2D.h
cnpy.h


* C++ idioms and patterns

- DetectionIdiom.h :: Detect of a templated type has a method.
- Type.h :: Get the type of something as a string.
- Range.h :: Turn pairs of iterators in to C++ ranges.
- Semaphore.h :: Limit a cooperatively shared resource to a maximum number of concurrent users.
- Singleton.h :: A single instance of some type.  Note, make very sparing use of this!
- ThreadSafeCache.h :: A thread-safe LRU map-like cache with bound size.
- ThreadSafeMap.h :: A thread-safe map-like object with not size bounds. 


- GeneratorIter.h
- IteratorBase.h


* Interfaces

WCT is heavily based on interfaces with most Interfaces defined in =iface/=.  These are all based on basic support from util.

- Interface.h :: The abstract base class for all WCT interface classes.

- IComponent.h :: Essentially all high level WCT objects are "components" meaning they implement at least one Interface and can be used via shared pointer.

- IFactory.h :: interface base class for a "named factory"

- NamedFactory.h :: the (only) named factory implementation.  This provides all of WCT's ability to dynamically find a component given its type/name.



* Uncategorized

DetectorWires.h
DfpGraph.h
Disjoint.h
DisjointRange.h
Dtype.h
ElasticNetModel.h
Faninout.h
FFTBestLength.h
Graph.h
GraphTools.h
HanaJsonCPP.h
HanaJson.h
IndexedGraph.h
IndexedMultiset.h
IndexedSet.h
Interpolate.h
Intersection.h
LassoModel.h
LinearModel.h


Math.h

NumpyHelper.h
ObjectArray2d.h
Pimpos.h

PointSummary.h

RandomIter.h
RangeFeed.h

RayClustering.h
RayHelpers.h
RaySamplers.h
RaySolving.h
RaySvg.h
RayTools.h

Response.h

Shared.h

Spectrum.h
SSSSAdapter.h


TupleHelpers.h

WireSchema.h


