#+title: Using clangd to develop WCT

Emacs eglot (and others) can talk to ~clangd~ to enrich the editing experience.

* Starting ~clangd~

Most likely your editor handles this.

* Configuring *clangd* as an LSP

To tell =clangd= various compiler flags run:

#+begin_example
$ ./wcb compile_flags
#+end_example

This makes a =compile_flags.txt= file in top level.  Do not commit this as it is
very specific to the local environment.  To remake it, remove the manually and
rerun.

WCT uses =.h= extensions for header files which =clangd= assume are C source unless
you have a =.clangd= file in the to of the source tree with these lines.

#+begin_example
If:
  PathMatch: ".*\\.h"
CompileFlags:
  Add: [ -xc++-header ]
#+end_example

To directly test a file:

#+begin_example
$ clangd --check=spng/inc/WireCellSpng/Torch.h --log=verbose
...
I[11:01:58.249] Loaded compilation database from /nfs/data/1/bviren/newsp/toolkit/compile_flags.txt
...
I[11:02:02.227] All checks completed, 0 errors
#+end_example

* Emacs with eglot and clangd

Besides making =clangd= happy with WCT, no special setup is needed.  Here is one
example config for eglot.

#+begin_src elisp
(use-package eglot
  :init
  (add-hook 'c-mode-hook 'eglot-ensure)
  (add-hook 'c++-mode-hook 'eglot-ensure)

  :hook ((python-mode . eglot-ensure)
         (c-mode . eglot-ensure)
         (c++-mode . eglot-ensure)
         )

  :config
  (setq eglot-code-action-indications '(mode-line))
  (add-to-list 'eglot-server-programs '((c++-mode c-mode) . ("clangd")))
  (add-to-list 'eglot-server-programs
               `(python-mode
                 . ,(eglot-alternatives '(("ruff" "server")
                                          "jedi-language-server"
                                          "pylsp")))))
#+end_src

When running Emacs locally to develop on a remote computer, use Tramp to access
your source files and eglot should Just Workâ„¢.

* Issues with clang as compiler

** ~backtrace.h~ not found

This header is provided by the compiler (or not).  It is provided by GCC but apparently (?) not clang.  It comes in through ~WireCellUtil/Exceptions.h~ which includes ~boost/stacktrace.hpp~ when ~HAVE_BACKTRACE_LIB~ is defined (in ~build/WireCellUtil/BuildConfig.h~.

Existence of ~backtrace.h~ is auto-detected by ~./wcb configure~ when GCC is used.  To let ~clangd~ cope with its ignrance you can manually edit the (generated!) ~BuildConfig.h~ to undefine the config flag:

#+begin_src c++
#define HAVE_BACKTRACE_LIB 1
#undef HAVE_BACKTRACE_LIB
#+end_src

And then rebuild.  This will mean that exceptions will not report stack trace.
