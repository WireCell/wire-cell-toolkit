#+title: WCT schema-based configuration

* Overview

The Wire-Cell Toolkit configuration sub-system provides run-time
directives to compiled code components.  In its most basic form, a
developer must provide code to interpret configuration information.
Developing such code is repetitive and error-prone and with varying
correctness.  Even when done well, no facility is provided to help the
end user to learn what structure is required, what are any default
values, etc.

To remedy these and other problems, Wire-Cell Toolkit now supports
defining configuration /schema/.  This allows a formal description of a
configuration object's data structure and its constituent types.

From the schema, two important actions can be driven: validation and
code generation (codegen).  Validation means to confirm that a given
object indeed matches the requirements described by a schema.  Codegen
is the act of producing some pristine code product by applying a
/template/ to a given schema.  As the codegen "knows" the schema, it may
also include elements of validation.

The rest of this document describes:

- how to develop a /schema/ for a component configuration
- what types of codegen WCT supports
- how to use it to greatly simplify your WCT component C++ code
- how to use it to help produce valid-by-construction configuration objects


* Writing a schema

In this section we will walk through the schema describing the
configuration objects expected by the [[../../gen/src/TrackDepos.cxx][​~TrackDepos~​]] component from the
~gen~ sub-package.

** File name, location and basic strucure

WCT places schema files next to public header files.  The one we will
be looking at is found in the source repository at:

[[../../gen/inc/WireCellGen/TrackDepos.schema][​~gen/inc/WireCellGen/TrackDepos.schema~​]]

The name and location of the schema file is important.  In the codegen
process it will be used to determine a C++ ~namespace~ as well as the
path of a generated C++ header, as we will see in more detail in
section [[Codegen]].

A schema file is written in the Jsonnet language with the help of
Jsonnet support provided by the schema system called *moo*.  As we will
walk through in detail next, the schema file can be considered to have
the following parts:

1. Import of Jsonnet modules for ~moo~ and any external schema
2. Construct some utility / helper objects.
3. A main body holding a "working object" where we define new data types.
4. A final line that processes the "working object" into an expected form.

** Imports

We import ~moo.jsonnet~ and perhaps also ~wirecell.jsonnet~ (eg, so we may
use proper units when we define default values).

#+begin_src jsonnet
local wc = import "wirecell.jsonnet";
local moo = import "moo.jsonnet";
#+end_src

Usually we will also want to import other schema so our schema may use
their types.  Most schema will include the "base" schema from the WCT
"util" sub-package:

#+begin_src jsonnet
local util_seq = import "WireCellUtil/Base.schema";
#+end_src

When considering others to import, it is important to consider that
generated C++ will have ~#include~ statements bringing in these
dependencies.  In particular, only import from "util" or perhaps "aux"
but never "across" different WCT plugins.

Lastly we will import a helper and its use will be described next.

#+begin_src jsonnet
local wcc = import "cfgschema.jsonnet";
#+end_src

** Helpers

To help assure the data structures that comprise the schema itself are
correctly formed, we rely on some helper objects.  These are made next
as:

#+begin_src jsonnet
local t = moo.oschema.hier(util_seq).WireCellUtil.Cfg.Base;
local f = wcc("Gen","TrackDepos");
local s = f.schema;
#+end_src

Comments:

- The ~hier()~ function converts the sequence into an object with keys
  named by the type names.  This lets the ~t~ object used later as a
  convenient source of referencing "base" types.

- The ~f~ object is a helper to create the schema namespace object ~s~ and
  at the very end to help output our schema in a proper form.

** Creating types

The main body of the schema is a "working object" which we temporarily
hold as:

#+begin_src jsonnet
local hier = {
  // ...    
};
#+end_src

Inside the body of this object we will one attribute for each type.
The "working object" is used so that we describe a compound type in
terms of a reference from another.  We will also refer to "base" types
in the ~t~ object created above.

Here is an initial type for ~TrackDepos~:

#+begin_src jsonnet
    local hier = {
    
        track: s.record("Track", [
            s.field("time", t.Time, 0.0,
                    doc="Absolute time at the start of the track"),
            s.field("charge", t.Charge, -1.0,
                    doc="If negative, number of electrons per depo, else electrons per track"),
            s.field("ray", t.Ray,
                    doc="The ray defining the track endpoints"),
        ], doc=""),
  
        tracks: s.sequence("Tracks", self.track,
                         doc="A sequence of tracks"),
        // ...
  
    };
#+end_src

Here,

- we define a ~Track~ type as a ~record~ with ~fields~ called ~time~, ~charge~ and ~ray~.
- the types of the fields are set using structured defined in the ~Base~ module
- we define a collection of tracks as a ~sequence~
- for all types and for fields in the record we give "docstrings"
- for fields we can give default vales

The final part of the "working object" defines the "main"
configuration object type.  We create it through the ~s.component()~
function so that certain naming conventions can be enforced.

#+begin_src jsonnet
  local hier = {
  
      // ...
  
      cfg: s.component([
          s.field("step_size", t.Distance, 1.0*wc.mm,
                  doc="Distance along track between two neighboring depos."),
          s.field("clight", t.Normalized, 1.0,
                  doc="Fraction of speed of light at which track progresses"),
          s.field("group_time", t.Time, -1,
                  doc="If positive, chunk the depos into groups spaning this amount of time with an EOS delimiting each group.  O.w. all depos are sent out as a stream."),
          s.field("tracks", self.tracks,
                  doc="Description of tracks on which to generate depos.")
      ], "Configuration for TrackDepos component"),
  
  };
#+end_src

** Final result

The final line of a schema file evaluates ~local~ objects in order to
produce types in the required sequence form:

#+begin_src jsonnet
util_seq + f.build(hier)
#+end_src

Details of this post processing are in ~moo~ documentation.  Look for
~moo.oschema.sort_select~ if interested.  For here, just a few things
need to be understood.

- Since we used a few types from the "base", we prepend the entire
  sequence.  The fact that this adds "extra" types is not a problem.

- The second part of the output sequence is produced by the call to
  ~f.build(hier)~.  This will convert the values of the "working object"
  ~hier~ into a sequence and in a proper order according to any type
  dependencies.


* Introducing moo 

We will use the ~moo~ command next in order to exercise our schema.  The
*moo* package provides support for defining schema and exercising schema
through templates to generate a wide variety of products.

WCT's build system will automatically use ~moo~ to generate code.
However, installing ~moo~ is required only to regenerate code such as
when modifying existing or adding new schema.  To avoid requiring ~moo~
WCT takes the somewhat unusual choice to commit the moo-generated
header files to the repo.

To learn how to install ~moo~ see:

  https://brettviren.github.io/moo/moo.html#install

What follows is self-contained usage information but see the moo web
site for additional documentations and examples.

* Testing a schema

Sometimes we may not write perfect Jsonnet on the first try (though it
is possible!).  Especially when beginning it is best to test the
syntax frequently as we add more code.  This can be done like:

#+begin_example
❯ moo -M cfg -M util/inc -M util/schema \
    compile gen/inc/WireCellGen/TrackDepos.schema
#+end_example

See the ~moo~ documentation for details and some more info below.  If
successful, you should see JSON printed to your terminal.

* Testing codegen

With ~moo~ we say we /render/ a /model/ against a /template/ in order to
generate code or other artifacts.  See the ~moo~ documentation to
understand these terms.  For the most part, the WCT developer needs to
only know the basics:

- template :: a file written in some target syntax (eg C++)
  interspersed with Jinja2 macros and markup.

- model :: a transformation of some data structure (eg a schema) into
  a new data structure to fit expectations of a template.

- render :: applying a schema to a template via a model

To further test your schema, it is useful to see how well it renders
to a C++ header file to reflect into ~struct~ and other types.

#+begin_example
❯ moo -g /lang:ocpp.jsonnet \
    -M util/inc -M cfg -M util/schema \
    -A path=WireCell.Gen.Cfg.TrackDepos \
    -A os=gen/inc/WireCellGen/TrackDepos.schema \
    render omodel.jsonnet util/schema/cfg.hpp.j2
#+end_example

See the ~moo~ documentation for the meaning of these arguments.  For
here, we say a few points

- The ~omodel.jsonnet~ file is provided by ~moo~ and defines the "model"
  object to be formed.
- The ~cfg.hpp.j2~ file is provided by WCT (in ~util/schema/~) and defines
  the "template" to which the model is applied.
- The ~-M~ adds directories to the path in which Jsonnet files are
  searched.  You may also add them to the env. var. ~MOO_LOAD_PATH~.
- The ~-A~ are Jsonnet /top-level arguments/ (TLAs) to the function defined by ~omodel.jsonnet~.

If all goes well you will see a C++ header file printed to stdout.  

* Build system

WCT's ~wscript~ will automatically process a schema to generate code by
locating them in the source area at

#+begin_example
<pkg>/inc/WireCell<Pkg>/<Component>.schema
#+end_example

So far two file are generated for each ~.schema~ file:

- ~<pkg>/inc/WireCell<Pkg>/Cfg/<Component>.hpp~ reflects the
  schema into C++ types and serialization methods.

- ~cfg/schema/<pkg>/<component>.jsonnet~ provides Jsonnet functions that
  may be used to help construct configuration objects.  These
  insinuate some validation code so any bugs in configuration code are
  caught at Jsonnet compile time.

If ~moo~ is not found during ~./wcb configure ...~ or if no change has
been made to the ~.schema~ files, no codegen will be performed.

* Refactoring configurable component

Before the above schema and codegen support was added to WCT, many
configurable components have been developed.  Their "old style" code
patterns can continue to work.  However, with a small amount of work
they can be refactored and the resulting C++ code will become simpler
and more robust.

The basic steps are:

1. Develop new schema matching existing.

2. Change base class from ~IConfigurable~ to ~Aux::Configurable<Config>~

3. Remove ~default_configuration()~ and ~configure()~ methods.

4. Translate usage of configuration info from JsonCPP to ~m_cfg~.

Details for each step are now given using ~TrackDepos~ as an example.

** Develop new schema

Depending on the component, the code which (implicitly) defines the
configuration schema may be concentrated in the ~IConfigurable~
interface methods or may be more broadly spread throughout the other
methods of your component.  Read though carefully to find where the
JsonCPP object is accessed.  Every key used to access it should become
a field in a record schema.

For this initial refactoring, it is suggested to avoid making changes
to the implicit schema.  Focus on performing a *transliteration* from
implicit to explicit.

** Change base classes

Old style code gained configuration by implementing the ~IConfigurable~
interface base class.  Remove it from the inheritance chain and add
instead ~Aux::Configurable<Config>~.  Focusing on just the relevant
lines:

#+begin_src c++
#include "WireCellAux/Configurable.h"
#include "WireCellGen/Cfg/TrackDepos.hpp"
namespace WireCell::Gen {

  using WireCell::Gen::Cfg::TrackDepos::Config;
  
  /// A producer of depositions created from some number of simple, linear tracks.
  class TrackDepos : public Aux::Logger,
                     public Aux::Configurable<Config>, 
                     public IDepoSource {  

#+end_src

The ~Config~ type is a ~struct~ from ~Cfg/TrackDepos.hpp~ which was
generated from the schema.

** Remove ~IConfigurable~ methods

In old style code we defined two methods of the ~IConfigurable~
interface to handle configuration information:

- ~default_configuration()~ to return a default JsonCPP object
- ~configure()~ to accept a JsonCPP object from user

Both of these are now provided by the ~Aux::Configurable~ base class and
should eventually be *removed* from your component class.  There are
some caveats w.r.t. ~configure()~:

- The ~configure()~ method is also used as a one-time, post-config entry
  method.  If your component requires that entry, move the
  initialization code into a new ~configured()~ method.  This will be
  called by the base class at the end of ~configure()~.

- In rare cases, ~configure()~ may be kept if some munging of the
  JsonCPP object is needed.  For example, to keep backwards
  compatibility wit some obsolete (implicit) schema.

** Translate usage of config info

The ~Aux::Configurable<Config>~ base class provides a ~protected~ data
member of type ~Config~ called ~m_cfg~.  This ~struct~ has all its
attributes set according to schema default and user-provided config
data.  It is thus what your new refactored code should use.

In translating to using ~m_cfg~ a number of patterns will likely be seen:

- Where the JsonCPP object was held as a member, translate its use, eg, from ~m_jcfg["key"]~ to ~m_cfg.key~.
- Where a config value was stored as a member, eg with ~m_key = get(cfg, "key", m_key)~ delete the ~m_key~ as an class attribute and instead use ~m_cfg.key~ in the code.


* Configuration objects construction functions

Besides generating C++, we use the schema to generate Jsonnet which
defines configuration object construction functions.  These functions
help define configuration objects as they insinuate type validation
code and provide arguments which reflect the schema.  Both patterns
help to turn bugs that would otherwise not be caught until run-time
into bugs that are caught more immediately by the Jsonnet compiler.

As described above, these are defined in files under
~cfg/schema/<pkg>/<component>.jsonnet~.  Some example usage:


#+begin_src jsonnet
  local b = import "schema/util/base.jsonnet";
  b.util.base.Point()
#+end_src

Gives:

#+begin_src json
{
   "x": 0,
   "y": 0,
   "z": 0
}
#+end_src

While trying to give some wrong value:

#+begin_src jsonnet
b.util.base.Point(wrong=42)
#+end_src

Gives

#+begin_example
RUNTIME ERROR: function has no parameter wrong
	<cmdline>:1:46-73	
#+end_example

Or a wrong type:

#+begin_src jsonnet
b.util.base.Point(x="fortytwo");
#+end_src

#+begin_example
RUNTIME ERROR: Assertion failed.
	cfg/schema/util/base.jsonnet:24:22-58	function <anonymous>
	cfg/schema/util/base.jsonnet:51:16-39	object <anonymous>
	During manifestation	
#+end_example

* Conversion to-do

** [4/48] gen [8%]

Below is a check list of components to refactor.  Maybe daunting but
as a point of comparison, Ductor took about 30 minutes while also
paying attention to meetings and fixing some regressions added to
TrackDepos.

#+begin_example
❯ for n in (grep -c IConfigurable *.h|grep -v :0 | sed -e 's/\.h:.*//g')
      echo -- '- [ ] '$n
  end
#+end_example

** gen

- [ ] AddCoherentNoise
- [ ] AddNoise
- [X] AnodePlane
- [ ] BlipSource
- [ ] ColdElecResponse
- [ ] DepoBagger
- [ ] DepoChunker
- [ ] DepoFanout
- [ ] DepoFramer
- [ ] DepoMerger
- [ ] DepoSetFanout
- [X] DepoSplat
- [ ] DepoTransform
- [ ] DepoZipper
- [ ] Detsim
- [ ] Diffuser
- [ ] Digitizer
- [ ] Drifter
- [X] Ductor (removed)
- [ ] EmpiricalNoiseModel
- [ ] Fourdee
- [ ] FrameFanin
- [ ] FrameFanout
- [ ] FrameSummer
- [ ] MegaAnodePlane
- [ ] Misconfigure
- [ ] MultiDuctor
- [ ] NoiseSource
- [ ] PerChannelVariation
- [ ] PlaneDiffuser
- [ ] PlaneImpactResponse
- [ ] Random
- [ ] RCResponse
- [ ] RecombinationModels
- [ ] Reframer
- [ ] ResponseSys
- [ ] Retagger
- [ ] SilentNoise
- [ ] StaticChannelStatus
- [ ] TimeGatedDepos
- [X] TrackDepos
- [ ] TruthSmearer
- [ ] TruthTraceID
- [ ] WarmElecResponse
- [ ] WireBoundedDepos
- [ ] WireParams
- [ ] WireSchemaFile
- [ ] WireSource

** sio

- [ ] BeeDepoSource
- [ ] JsonDepoSource
- [ ] NumpyDepoLoader
- [ ] NumpyDepoSaver
- [X] NumpyFrameSaver
