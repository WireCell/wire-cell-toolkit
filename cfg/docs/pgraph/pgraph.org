#+title: Wire-Cell Toolkit Data Flow Graph Configuration

#+setupfile: pgraph-local.setup

#+LATEX_HEADER: \usepackage[margin=1.0in]{geometry}
#+options: ':t
#+PROPERTY: header-args:jsonnet :dir .
#+PROPERTY: header-args :cache yes

* Introduction

Wire-Cell Toolkit (WCT) implements the [[https://en.wikipedia.org/wiki/Dataflow_programming][/data flow programming/]] (DFP) pattern.
The "programming" is done by describing a graph with vertices or /nodes/
representing operations on data objects that are transferred (flow) through
graph /edges/.

This document describes the concepts of WCT DFP, how its graphs are represented,
how to describe graphs through a configuration language, how that configuration
is used by the toolkit to construct, configure and connect C++ components and
finally how to implement a WCT DFP graph node.


* Concepts

The DFP pattern is conceptually simple but there are choices in how to apply it.
This section describes the choices and defines the terms in WCT's
implementation of DFP.


** Directed acyclic graph.

WCT DFP uses a *directed acyclic graph* (DAG).  This simply means that data
flows in one direction along any given edge and there is no path in the graph
that cycles back to any given node.  A node in a DAG thus has two sets of edges:
*output edges* carry data produced by a node and *input edges* carry data
consumed by a node.

** Port graphs

WCT DFP uses a *port graph* (PG or pgraph).  In a port graph, an edge connects
to a node via an identified "port".  Given WCT DFP graph is also a DAG, there
are is a list of "input ports" (or /iports/) and "output ports" (/oports/).

** Graph rules

WCT DFP graphs have rules that govern edge connections:

1. Exactly one edge may connect a pair of ports.

2. Connect ports must reside in different nodes.

3. Exactly one type of data object is passed by an edge.


** Atomic nodes, incomplete subgraphs and complete graphs

The number of iports and oports is predetermined by a node's definition.  A
*complete graph* has all ports connected and an *incomplete subgraph* has open
ports that are still available for connection.  By collecting all open ports, a
subgraph can be logically considered a singe *aggregate node* of many *atomic
nodes*.  We use term *pnode* ("ported node") to generically refer to atomic and
aggregate nodes.  A complete graph is thus a single pnode with no open ports.


* Representation 

A WCT DFP graph is represented in terms of the following objects.  The next
section will describe the language forms to define these objects but for now, simply assume they follow the general JSON data model.

** Inode

An *inode* object represents an *instance* of a WCT C++ *component class*.  A DFP node is a component but not all components are nodes and an inode represents them as well.  These others can be described as "service" or "tool" components.  As we will see, an inode is a container for component configuration, though not all components are configurable.

An *inode* object is defined by these attributes:

- type :: A string identifying the WCT =type name= (see description of =WIRECELL_FACTORY=).
- *name* :: A string unique among all instance of a common *type*.  Can be empty if the instance is a singleton of the type.
- data :: An object providing configuration to the instance.  Can be empty or omitted if the type is not configurable or its default configuration is sufficient.
- uses :: A set of other inodes or pnodes that this inode refers to by name in a data attribute.  Can be empty or omitted.  (See section [[Uses]]).

** Pnode

A *pnode* represents either an *atomic inode* or an *aggregate of other pnodes*.
It has some similarities with an inode, but the two are not interchangeable.
A *pnode* object is defined by these attributes.

- type :: The literal string ="Pnode"=.
- name :: When representing an atomic inode, a string formed from *inode.type* and *inode.name* and may otherwise be omitted.
- iports :: An ordered list of input ports (See section [[Port]]).
- oports :: An ordered list of output ports.
- edges :: A set of edge representations (See section [[Edge]]).
- uses :: A set of other pnodes that the pnode aggregates.  (See section [[Uses]]).

#+begin_note
From here, the document will use the generic term *node* to refer to either
*inode* or *pnode* in contexts where no distinction exists.
#+end_note


** Port

A *port* object is represented with these two attributes

- node :: The *pnode.name* of the inode that holds to port.
- port :: The index number of the port in its port list.

#+begin_note
While the port "knows" its node, the port list in which the port resides (input or output) is not recorded.  Also, ports may only refer to atomic pnodes.   Any ports exposed by an aggregate pnode are its internal atomic pnodes.
#+end_note

** Edge

An *edge* represents an ordered connection from an *output port* to an *input
port*.  It has these attributes.

- tail :: an output port object
- head :: an input port object

Think of an edge as an arrow pointing from its arrow tail to its arrow head.

** Uses

Both *inode* and *pnode* has a *uses* set that holds other inode or pnode
instances for which the node references by name in the *data* object.

#+begin_note
All nodes must be reachable from the final complete graph node via *uses* lists. 
#+end_note

** Graph

A WCT DFP graph has two representations: a *complete-graph pnode* and a *list of
nodes*.  The list of nodes is derived from the complete graph pnode by applying
a topological sort to the object dependency graph built from the *uses* lists
and it adds a final inode which represents a *graph execution engine* component.
This component holds the list of all edges.  The derivation of the list of nodes
is automatic and covered in the next section.


* Construction
:PROPERTIES:
:header-args:sh: :results graphics file :exports results :cache yes :width 50%
:END:

This section will walk through how to construct a WCT DFP graph.  It builds up gradually starting with the basics of the *Jsonnet* configuration language, how to define a graph node, how to connect nodes, how to develop graph construction functions and how to form the final list-of-nodes result.

** Jsonnet introduction

The Wire-Cell Toolkit can be configured in *Jsonnet*.  The Jsonnet language is a
superset of JSON that adds modules, functions, comments, list and object
comprehensions and a friendlier syntax.

#+begin_note
Jsonnet is a *purely* [[https://en.wikipedia.org/wiki/Functional_programming][functional programming language]].  Unlike with imperative
programming languages, variables may only be initialized and never modified.
#+end_note

The Jsonnet project provides excellent documentation.  In order the reader should look through:

- [[https://jsonnet.org/learning/tutorial.html][Tutorial]] walks through most of what one needs to know.
- [[https://jsonnet.org/ref/stdlib.html][Standard library]] describes the =std= object with many useful functions.
- [[https://jsonnet.org/ref/language.html][Language reference]] summarizes the language itself.

The rest of this document assumes the information provided in these links.


** WCT Jsonnet support

WCT provides some core Jsonnet files to assist in developing configuration.

- =wirecell.jsonnet= :: Wire-Cell system of units and basic utility functions that augment Jsonnet's =std=.
- =pgraph.jsonnet= :: A full suite of functions to build directed acyclic port graphs.

They are heavily commented and the user is expected to read them to learn all that they provide.   Here we will give introduce a fraction of functionality they provide.


Typically, a configuration file will start by importing one or both of these
core files:

#+begin_src jsonnet
  local wc = import "wirecell.jsonnet";
  local pg = import "pgraph.jsonnet";
#+end_src
  
** Locating Jsonnet files

These and other Jsonnet files provided by WCT reside in the source at
=wire-cell-toolkit/cfg/= or may be installed by WCT under
=$PREFIX/share/wirecell/=.  Jsonnet files given to the =import= operation will
be located by searching an ordered path list:

1. Directory holding the current Jsonnet file.
2. Current working directory.
3. An externally provided path list.

WCT will use the colon-separated path list provided by the =WIRECELL_PATH= shell
environment variable in a first-found-wins manner.  In addition, WCT command
line programs (=wire-cell= and =wcsonnet=) accept optional arguments =-P/--path=
to add search paths to the list.  The generic =jsonnet= program accepts =-J/--jpath= and =JSONNET_PATH=.

#+begin_warning
WCT walks the =WIRECELL_PATH= in the forward direction (left-to-right) while =jsonnet= walks =JSONNET_PATH= in the *reverse* direction.
#+end_warning

** Building an =inode=

The most fundamental object in a WCT configuration is an *inode* (see section [[Inode]]).  We will use the =Drifter= component as an example.

#+begin_src jsonnet
  {
      type: "Drifter",
      name: "",
      data: { /* ... */ }
  }
#+end_src

#+begin_note
Typically, a single =Drifter= is used and thus it does not require a name.  We must supply a unique *name* when the same *type* is used more than once in a graph.  
#+end_note

This example appears simple but there are some hidden complexities:

- How do we know the proper "spelling" for the *type*?
- What attributes of *data* are supported?
- When can we rely on default values for *data* attributes?

In general, the answer to these questions is: *read the WCT C++*.  However, we can develop *Jsonnet libraries* that capture the salient information and reduce the burden.  A Jsonnet library is simply a Jsonnet file that other Jsonnet files import (like =pgraph.jsonnet=).  At lowest level, these can provide factory functions that encode the schema and default values for component configuration objects.

** Building a =pnode=

Here is an example of a library with a function that constructs a =Drifter= *inode* and return it wrapped in a *pnode*.

#+include: drifter.jsonnet src jsonnet

#+RESULTS:
#+begin_src json
#+end_src

For brevity, we have omitted some required parameters.  A user may then make a drifter pnode by "importing" the Jsonnet library and calling the function.

#+include: drifter-object.jsonnet src jsonnet

#+html:<details> <summary>Click for the JSON</summary>

#+include: drifter-object.json src json


#+begin_note
This one time we show the full expanded structure of just this single pnode to
appreciate the complexity that Jsonnet saves us from manually expressing.  While
the Jsonnet-level pnode structure is relatively simple (the *type*, *name*,
*data* trio), we can see here structure that is rather more complex.  The user
should not worry about this complexity as this structure is *ephemeral*.  It
includes information and arrangements needed to implement port graphs in
Jsonnet.  After the final list of nodes is produced, we would see structure
closer to the apparent Jsonnet inode except in JSON syntax.  
#+end_note

#+html: </details>


** Visualizing

A powerful tool for developing WCT DFP graphs is to visualize them.  The =wire-cell-python= package provides the =dotify= command that will render a graph using GraphViz.  To see a summary of how to use it run:

#+begin_src shell :exports both :results output :wrap example
wcpy pgraph dotify --help
#+end_src

The full command we will use to make the graph visualization in this section is: 

#+include: dotify.sh src shell

Visualizing requires the graph to be in the list-of-nodes form and not the pnode form.  We will discuss this transformation more in section [[Finalizing the graph]] but for now take it for granted:

#+include: drifter-graph.jsonnet src jsonnet

#+begin_src sh :file drifter-graph.svg
  ./dotify.sh drifter-graph.svg
#+end_src

#+RESULTS[89fcb88dd6f50fda9bfd108c393ee0722ae80a61]:
[[file:drifter-graph.svg]]

This shows a single node with the *type* and the *name* on the first two lines followed by the parameters.  The single input and output port, both numbered 0 are also shown.  Note, besides being rather trivial, this is an *incomplete subgraph* as both ports have no edges.

** Pipelines

A common graph pattern is a linear sequence of nodes called a *pipeline*.  Here is simple and abbreviated example that introduces some new node types:

#+include: drifter-pipeline.jsonnet src jsonnet

We visualize this time with the parameters omitted for brevity:

#+begin_src sh :file drifter-pipeline.svg
   ./dotify.sh drifter-pipeline.svg
#+end_src

#+RESULTS[033b16a9db01a95aa6e8aad3391d8dbbeaeba343]:
[[file:drifter-pipeline.svg]]


This is a *complete graph* as all ports are connected.  We say the first node is a *source* and the last a *sink*.  The middle is categorized as a *function* or sometimes a *filter* node.

#+begin_note
While this example graph renders properly, it is not sufficient for execution by WCT as no configuration parameters are given.  We will continue with these abbreviated examples in this section and later turn to making graphs that are correct for execution.
#+end_note

** Interning

To introduce the first non-trivial graph we used =pg.pipeline()=.  Before we introduce the rest of the family of subgraph construction functions we will jump to introducing =pg.intern()=.  With this function alone, we may construct any subgraph and the remainder of the family are merely simplified wrappers on =pg.intern()=. 

 Here is its function prototype, all arguments are optional:

#+begin_src jsonnet
  intern(innodes=[], outnodes=[], centernodes=[], edges=[], iports=[], oports=[])
#+end_src

- =innodes= :: A list of pnodes which will have their open *iports* become the *iports* of the resulting pnode.
- =outnodes= :: Same, but for *oports*.
- =centernodes= :: Nodes that are in the subgraph but which do not have available ports.
- =edges= :: A list of *edge objects*, usually only for edges between the provided nodes.
- =iports= :: Explicit list of *input ports* to expose, again typically from provided nodes.
- =oports= :: Same, but for *output ports*.

This function returns a *pnode* with a *uses* list holding all given nodes.  This single pnode is also the subgraph constructed of these nodes and edges. 

Here we repeat the pipeline example using =pg.intern()= instead of =pg.pipeline()=.

#+include: drifter-intern.jsonnet src jsonnet

This gives us an identical graph as `pg.pipeline()` at the cost off five lines instead of one.

** Fans

A consequence of the graph rules given in section [[Graph rules]] is that two edges can not connect to the same port nor can an edge have branches.  To effectively /split/ or /join/ an edge, we must use an  explicit *fanout* or *fanin* node, respectively.

#+include: drifter-fans.jsonnet src jsonnet

#+begin_src sh :file drifter-fans.svg
   ./dotify.sh drifter-fans.svg
#+end_src

#+RESULTS[93db770ed93f55da3599495f87ef266f9b1d2a1f]:
[[file:drifter-fans.svg]]

The elaborate, monolithic call to `pg.intern()` can be be simplified by composing two more fundamental functions.

#+begin_src jsonnet
// source fanout, pipes, fanin, sink
local fanpipe = pg.fan.pipe('DepoSetFanout', drifters, 'DepoSetFanin');
local graph = pg.pipeline([source, fanpipe, sink]);
#+end_src


** Crosslines

** Compound endpoints







** Finalizing the graph

=pg.main()=

* C++ configuration

- tbd: loading, construction, configuration dispatch
- tbd: ad-hoc JSON object vs Hana struct
- tbd: issues with C++ side of things (ad-hoc vs hana, discovery of *type* and contents for *data*)

* C++ DFP graph node components 

Each node has a /component type/ (mapped to a C++ class, first argument to the
~WIRECELL_FACTORY()~ CPP macro call) and an instance name and a set number of
/input ports/ and /output ports/.  These kinds of graph are sometimes called "port
graphs" and the "p" in "pgraph" stands for "port".  Each port allows passage of
data objects of a specific interface type (a subclass of ~IData~) as determined by
the C++ node class on either end of the edge.  A valid graph has exactly one
edge between any pair of ports.

WCT is described with a simple list of component configuration objects.  Many of
these objects will configure individual nodes in the graph, but other "tool" or
"service" components are also included.  One component is special and defines
the edges of the graph in terms of ~<type>:<name>~" pair.  The ~<type>~ is the
/component type/ and the ~<name>~ is an /instance name/ to make the node unique when
multiple nodes of the same component type may exist.  If exactly one instance of
a component type exists, it can be identified with just ~<type>~.

While very simple in representation, properly forming and reasoning about
complex graphs configurations is more difficult.  To help with this, WCT
provides the ~pgraph.jsonnet~ library of functions.


* Meta :noexport:

#+begin_src shell :results none
rsync --exclude '*~' -a . hierocles.phy.bnl.gov:public_html/wire-cell/docs/pgraph/
#+end_src

