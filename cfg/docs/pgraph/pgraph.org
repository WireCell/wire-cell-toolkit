#+title: WCT ~pgraph~ configuration support
#+LATEX_HEADER: \usepackage[margin=1.0in]{geometry}
#+options: ':t

* Introduction

The most popular way to construct WCT jobs is via its support for "data flow
programming" (DFP).  The "programming" here means constructing a graph with
vertices or /nodes/ representing operations on data objects that are transferred
between nodes on /edges/.

This document describes the concepts of WCT DFP graphs, how to construct them
via configuration, how that configuration is used by WCT to construct, configure
and connect C++ components and the special code required to turn a WCT component
into a DFP graph node.

* Concepts of WCT DFP graphs

** Directed acyclic graph.

The WCT DFP graph is a *directed acyclic graph* (DAG).  This simply means that
data flows in one direction along any given edge and there is no path in the
graph that cycles back to any given node.  A node in a DAG thus has two sets of
edges: "out edges" carry data produced by a node and "in edges" carry data
consumed by a node.

** Port graphs

The WCT DFP graph is a *port graph* (PG or pgraph).  In a port graph, an edge connects to a
node via an identified "port".  Given WCT DFP graph is also a DAG, there are two
sets of ports: "in ports" (or /iports/) and "out ports" (/oports/).  In side its
set, a port is identified by an /index/ number.

** Graph rules

WCT DFP graphs have rules that govern connections:

1. Nodes only connect to (hold) ports.

2. Exactly one edge may connect to any two ports.

3. An out port of one node connects to an in port of a different ndoe (DAG).

4. An edge and its ports pass a sequence of data units of a well-defined data type (=IData=).

** Complete and incomplete graphs

In WCT DFP graphs, the number of input and output ports in any given node is
predetermined when that node is created.  If a graph has all ports connected we
call it *complete* and otherwise we call it an *incomplete subgrap* (or often, less
properly, just "subgraph").


** Atomic and aggregate nodes

Port graphs have a powerful scaling feature that assists in their construction.
An incomplete subgraph can be interpreted as a node by collected all
disconnected iports and oports across its nodes.  This allows the aggreagte
subgraph-as-node to be used for further construction in the same way that a
single, atomic node may be.  We give the name *pnode* to mean either an atomic
node or an aggregate, incomplete subgraph.  And, indeed, a complete WCT DFP
graph is simply a single pnode with no ports.

** Graph representation 

A WCT DFP graph is represented in terms of the following objects.

*** Inode

An *inode* represents an instance of a WCT C++ component class (=IComponent=
interface base class).  The component implementation is most often a DFP node
type (=INode=) and a configurable type (=IConfigurable=) but in some cases a
component is only one of these types or neither.  An *inode* object is defined by
these attributes:

- type :: A string identifying the WCT =type name= (see description of =WIRECELL_FACTORY=).
- *name* :: A string unique among all instance of a common *type*.  Can be empty if the instance is a singleton of the type.
- data :: An object providing configuration to the instance.  Can be empty or omitted if the type is not configurable or its default configuration is sufficient.
- uses :: A set of other inodes or pnodes that this inode refers to by name in a data attribute.  (See section [[Uses]]).

*** Pnode

A *pnode* represents either an atomic *inode* or an aggregate of other pnodes.  A
*pnode* object is defined by these attributes:

- type :: The literal string =Pnode=.
- name :: A string formed from *inode.type* and *inode.name* for atomic pnodes and may otherwise be omitted.
- iports :: An ordered list of input ports.
- oports :: An ordered list of output ports.
- edges :: A set of edge representations.
- uses :: A set of other pnodes that the pnode aggregates.  (See section [[Uses]]).

*** Port

A *port* object is represented with these two attributes

- node :: The =pnode.name= of the node that holds to port.
- port :: The index number of the port in its set.

While the port "knows" its node, there is no representation stating if the port
is in the input or the output set.  No "loose" port objects are kept and a port
set context is provided by an edge.

*** Edge

An *edge* represents an ordered connection from an output port to an input port.
It has these attributes.

- tail :: an output port object
- head :: an input port object

Think of an edge as an arrow pointing from its arrow tail to its arrow head.

*** Uses

Both *inode* and *pnode* has a *uses* set.  This allows for either to hold objects
that are referenced by name in the *data* object.  Holding referenced objects is
required to order the final set of configuration objects by their dependencies.
See the section [[C++ configuration]].

*** Graph

A WCT DFP graph is represented by a flat list of *inode* objects in order of their
"uses" dependency.  The last inode in the list configures a *graph execution
engine* component (Pgraph or TbbFlow).  All such engines are configured
identically with a list of all the edges of the graph.


* Constructing graphs with Jsonnet configuration

This section will walk through how to construct a WCT DFP graph.

** Jsonnet

Ultimately, a final WCT configuration can be expressed in JSON.  JSON is purely
a data structure language.  It lacks any construction features whatsoever.  We
use the Jsonnet language to perform data construction.  Jsonnet can be
summarized as JSON plus extras.  The extras include modules, functions,
comments, list and object comprehensions and a JSON-like but friendlier syntax.
Jsonnet is a purely functional language in that variables can only be
initialized to a value and never modified.

** WCT Jsonnet support

WCT provides some core Jsonnet files (Jsonnet "libraries" aka "modules") for
using Jsonnet to construct configuration.

- =wirecell.jsonnet= :: Wire-Cell system of units and basic utility functions.
- =pgraph.jsonnet= :: A full suite of functions to build directed acyclic port graphs.
  
In addition, WCT provides Jsonnet files containing higher level abstractions to
the construction process.  Before introducing them, we will show how to use the
core function, focusing primarily on =pgraph.jsonnet=.

** Building an inode

The most atomic unit is an *inode* object that will cause a C++ instance to be
constructed and potentially configured.  We will create a =Drifter= which is the
component in WCT simulation responsible for drifting energy depositions
("depos") in the bulk of the detector.  It is most direct created simply by
typing out the structure as Jsonnet:

#+begin_src jsonnet
  {
      type: "Drifter",
      name: "",
      data: { /* ... */ }
  }
#+end_src

To know the *type* we must check the first argument to the =WIRECELL_FACTORY= C++
macro in the component source file.  And to know what may or must be placed in
*data* we must, in general, examine the C++ implementation source.  See section
[[C++ configuration]] for details.  Here, we give the object an empty string for its
name as one drifter can service an entire detector.

To help future configuration authors, a friendly developer can provide a Jsonnet
function that helps to build the structure.

#+include: drifter.jsonnet src jsonnet

#+RESULTS:
#+begin_src jsonq
#+end_src

For brevity, this omits some required parameters.  A user may then make an
instance of a drifter configuration object:

#+begin_src jsonnet :results value
  local drift = import "drifter.jsonnet";
  drift.drifter(); // accept defaults
#+end_src


* C++ configuration

- tbd: loading, construction, configuration dispatch
- tbd: ad-hoc JSON object vs Hana struct
- tbd: issues with C++ side of things (ad-hoc vs hana, discovery of *type* and contents for *data*)

* C++ DFP graph node components 

Each node has a /component type/ (mapped to a C++ class, first argument to the
~WIRECELL_FACTORY()~ CPP macro call) and an instance name and a set number of
/input ports/ and /output ports/.  These kinds of graph are sometimes called "port
graphs" and the "p" in "pgraph" stands for "port".  Each port allows passage of
data objects of a specific interface type (a subclass of ~IData~) as determined by
the C++ node class on either end of the edge.  A valid graph has exactly one
edge between any pair of ports.

WCT is described with a simple list of component configuration objects.  Many of
these objects will configure individual nodes in the graph, but other "tool" or
"service" components are also included.  One component is special and defines
the edges of the graph in terms of ~<type>:<name>~" pair.  The ~<type>~ is the
/component type/ and the ~<name>~ is an /instance name/ to make the node unique when
multiple nodes of the same component type may exist.  If exactly one instance of
a component type exists, it can be identified with just ~<type>~.

While very simple in representation, properly forming and reasoning about
complex graphs configurations is more difficult.  To help with this, WCT
provides the ~pgraph.jsonnet~ library of functions.

* ~pgraph~ concepts

** inode

In ~pgraph.jsonnet~, a configuration object for an particular instance
of a WCT component that has an ~INode~ interface is called an *inode*.  As
introduced above an *inode* must have a ~type~ attribute and may require a
~name~ attribute.  If the WCT component is configurable (has an
~IConfigurable~ interface) then the *inode* may also have a ~data~ attribute
to supply a configuration parameters to the component instance of a
type given by ~type~.

** pnode

One very useful intermediate construction which is supported by port
graphs is that of forming a "aggregate" node from a subgraph.  This
hides arbitrary complexity of a subgraph by conceptually presenting
the whole as a single node.  Any unattached ports from any of the
subgraph nodes are assigned to the aggregate node.  A user may connect
this node into a yet larger graph without the need to understand the
internal complexity.  This abstraction can be repeated to arbitrary
scale.  That is one may construct an entire DFP graph as aggregates of
aggregates of nodes, etc.

The most important functions in ~pgraph.jsonnet~ are those that provide
ways to form various types of subgraph aggregate nodes.  For this to
work, a new type of "node" is required that can represent individual
*inode* nodes as well as aggregates of *inode* nodes.  This is called a
*pnode*.  A *pnode* is structured similarly to an *inode*.  It has a ~type~
but all *pnode* has type of ~"Pnode"~.  A *pnode* may also have an instance
~name~ with the same governing rules as for *inode*.  Additional
attributes of a *pnode* hold the subgraph information and allow
unattached ports of the subgraph to be enumerated as if their were on
the *pnode* itself.

* ~pgraph~ functions

Here describes the most important functions.  Read the code and
comments in ~pgraph.jsonnet~ for details.  In the examples, we will
assume

#+begin_src jsonnet
local pg = import "pgraph.jsonnet";
#+end_src

** Port

** Edge

** Atomic pnode

The simplest *pnode* is one that represents a single *inode*.

#+begin_src jsonnet
  local mf = {type:"MyFilter"};
  local pnode = pg.pnode(mf, nin=1, nout=1);
#+end_src

If the component has compile-time port cardinality, the ~nin~ and ~nout~
arguments *must* match expectations.  For components with dynamic port
cardinality, ~nin~ or ~nout~ will set the number to be used.

** Pipeline of pnodes

A very common subgraph pattern is a linear pipeline of nodes.  These
can be aggregated as such:

#+begin_src jsonnet
  local mf1 = {type:"MyFilter", name:"foo"};
  local mf2 = {type:"MyFilter", name:"bar"};
  local pipe = pg.pipeline([mf1,mf2]);
#+end_src

The input ports of ~mf1~ form the input ports of ~pipe~ and likewise the
output ports of ~mf2~.

** Arbitrary subgraph aggregation

An arbitrary aggregation can be formed with the ~intern()~ function.  It
accepts zero or more *pnode* objects in three collections: ~innodes~,
~centernodes~ and ~outnodes~ along with zero or more edges in ~edges~ array
and input and output ports in ~iports~ and ~oports~.  In principle, all
other *pnode* creating functions can be implemented as calls to ~intern()~
with some restriction on which of these arguments are passed.

Using the *pnode* instances created above:

#+begin_src jsonnet
  local sg = pg.intern(innodes=[pnode, pipe], outnodes=[pnode,pipe]);
#+end_src

The result would be a *pnode* with two input and two output ports taken
from those of ~pnode~ and ~pipe~.

Emulating the ~pipeline()~ function:

#+begin_src jsonnet
  local pipe2 = pg.intern(innodes=[mf1],outnodes=[mf2],
                          edges=[pg.edge(mf1,mf2)]);
#+end_src

Or a longer pipeline with three nodes

#+begin_src jsonnet
  local pipe2 = pg.intern(innodes=[mf1],centernodes=[mf],outnodes=[mf2],
                          edges=[pg.edge(mf1,mf), pf.edge(mf,mf2)]);
#+end_src

So far, the ports of the resulting *pnode* are calculated assuming all
input ports of input nodes are open and likewise for output.  The
order of these ports on the resulting *pnode* follows the order of the
nodes in their arrays and the ports in each node.

In some cases, ports may no be available for attaching or one may wish
to expose ports in a different order.  In such cases ~iports~ and ~oports~
can be explicitly given.

For example, a common subgraph pattern is an "edge tap" whereby we
wish to send to its nominal recipient as well as a new consumer.  We
must have exactly one edge per port and so we may not "split an edge".
However, there are components called "fanout" which produce a number
of parallel outputs from each input.

Here is a very contrived example:

#+begin_src jsonnet
  local fanout = pg.pnode({type:"MyFanout"}, nin=1, nout=3);
  local tapped = pg.intern(innodes=[mf], centernodes=[fanout], outnodes=[mf1,mf2],
                           edges=[pg.edge(mf,fanout),
                                  pg.edge(fanout,mf1,1,0),
                                  pg.edge(fanout,mf2,2,0)],
                           oports=[mf2.oports[0], mf1.oports[0], fanout.oports[0]]);
#+end_src

Output port 0 of the ~fanout~ is left unconnected and output port 1 of
the ~fanout~ connects to the input port of ~mf1~ and likewise for 2.  If
~oports~ were not given then the output ports of the resulting ~tapped~
*pnode* would be in order port 0 from ~[fanout,mf1,mf2]~.  For reasons
only known to the user, the reverse ordering was explicitly wanted and
given by ~oports~.

** Fans and taps

Note, ~pgraph~ provides a subobject called ~fan~ with various functions to
construct fan in/out subgraphs: ~fanout(), fanin(), pipe(), sink()~.  It
also provides the ~tap()~ function to make constructing "edge taps" as
described above simple.

** Edge insertion

** Aggregate closed component graphs

* C++ graph node classes

** C++ component configuration

The configuration in Jsonnet gets to an /instance/ of a C++ component that
inherits from ~IConfigurable~ via the method

#+begin_src c++
  void configure(const Configuration& cfg);
#+end_src

The ~Configuration~ class is a C++ object equivalent to the JSON component
configuration object described above.  The C++ ~IConfigurable~ component should
interpret the ~Configuration~ object for a set of established attributes, handle
type conversion, default values and raise exception if required values are
missing or the wrong type or have illegal value.

The ~configure()~ method is guaranteed to be called in a single-threaded context.
In most WCT jobs, ~configure()~ is called once and there is no "reconfigure".  Though, generally, class implementations should assume ~configure()~ may be called more than once.

An ~IConfigurable~ class may also provide default values with the method

#+begin_src c++
  Configuration default_configuration() const;
#+end_src

Any configuration provided by the user will be merged into this default object
by the WCT's configuration manager.  This method is also called in a
single-threaded context.

** Common C++ configuration idioms

An ~IConfigurable~ should use doxygen comments to state configuration parameters.
These comments may be placed anywhere in the class definition and often located
on attributes.  For example:

#+begin_src c++
  private:
      /// Configuration: "nticks"
      ///
      /// An integer specifying the number of samples.
      int m_nticks{6000};
#+end_src

Then in the two methods descried above:

#+begin_src c++
  Configuration MyClass::default_configuration() const {
      Configuration cfg;
      cfg["nticks"] = m_nticks;
      return cfg;
  }
  void MyClass::configure(const Configuration& cfg) {
      m_ticks = get(cfg, "nticks", m_ticks);
  }
#+end_src

** C++ graph class inheritance.

A C++ class inheriting from ~INode~ is a graph node class.  Almost all graph node
classes inherit from an interface further down the inheritance tree which
specifies the category of node (source, sink, function, fanin, fanout, etc) and
the types of data passed by nodes.  Eg an ~IFrameFilter~ node is an
~IFunction<IFrame,IFrame>~ node.  The reminder of this section describes
requirements on C++ class nodes

** Registration of a concrete component.

Every C++ node class must be registered with the WCT "named factory".  The
details of this factory are found elsewhere.  The node developer merely must add
lines in the node ~.cxx~ file like:

#+begin_src c++
  #include "WireCellUtil/NamedFactory.h"
  WIRECELL_FACTORY(<component-type-name>, <class>, <comma separated list of interfaces>)
#+end_src

For example, the "digitizer" node from the simulation is registered as:

#+begin_example
WIRECELL_FACTORY(Digitizer, WireCell::Gen::Digitizer,
                 WireCell::INamed,
                 WireCell::IFrameFilter,
                 WireCell::IConfigurable)
#+end_example

If a node class inherits from a concrete class, its interfaces must also be
listed.  For example, the ~Digitizer~ inheres from a very prolific base called
~Aux::Logger~ which is an ~INamed~.

** Callable DFP graph node operator and its return value.

Every node "executes" by a graph engine calling that nodes callable operator:

#+begin_src c++
  bool operator()(/*node type-specific arguments*/) const;
#+end_src

The arguments passed depend on the node.  Except for sources and sinks that have
a single argument, an input and an output argument are passed.  For example,
~Digitizer~ gets an input and an output ~IFrame::pointer~.  Some nodes such as
fanins and fanouts or queued-out types, get a vector argument.  Some special
nodes may have a tuple.

For all nodes except for source nodes, the boolean return value is ignored by a
graph execution engine.  For a source node it is critical to return ~false~ once
there is no more data to produce.  But, see next section about EOS.


** End-of-stream (EOS) protocol for data flow graph nodes

Every node must participate in the end-of-stream (EOS) protocol.  An EOS is used
to indicate exactly what its name says: a stream of objects has ended.  It is
conceptually modeled after NULL-terminated C strings.

An EOS marker always starts with a source node.  After the last "real" object is
output by a source node, it must send out exactly one EOS, still returning true.
If the graph engine calls the source again, and that source can not start a new
stream, then it must return ~false~.  Every other node must check for EOS on input
and forward EOS to all output.  Thus an EOS propagates through the graph.

When an EOS is encountered, the node should perform any flushing of cached data.
Often jobs will exit after an EOS completes its passage through the graph.  But,
if a source restarts a new stream then the graph will keep executing.

An EOS is always a ~nullptr~ but its placement depends on the type of argument to
the node's callable operator.

- scalar (eg, shared pointer) marks EOS as a ~nullptr~.
- vector (eg input to fanin, output to fanout) marks EOS as a vector full of ~nullptr~.
- queue (eg, Drifter) places an ~nullptr~ into its output vector, usually at the end.

Specifically, an empty vector for a fanin/fanout is illegal and something has
gone horribly wrong.  A queued-out node may have an empty vector if it simply
has not produced anything.  Asynchronous branch/merge nodes have data on just
one port so any port with EOS means EOS.

** Not-EOS

Some ~IData~ is a collection of other ~IData~.  For example, an ~IFrame~ has a vector
of ~ITrace~.  Such aggregate data types can have empty collections.  These are NOT
EOS.  If an aggregate type with an empty collection is input to a node, it still
must be processed and a valid output produced.  Typically, this means the output
likewise is in some ways "empty".


* Performance

Some Jsonnet forms can contribute to drastically large Jsonnet compilation
times.  The main cause is that Jsonnet tends to reevaluate forms that are
repeatedly used.  The Go version does a much better job of internally caching
objects than the C++ version, and WCT has moved to use it by default.  However,
surprisingly long compilation times can still be encountered.  Here are some
recommendations to avoid introducing problems.

** Avoid computational complexity

Be cautious of producing a function that scales poorly with the size of its
input.  This is a general precaution but as Jsonnet is a /purely functional/
programming language with a somewhat limited standard library it can be
particularly easy to solve a problem with a bad algorithm.  It may be fast in
testing and only show a problem as the configuration grows.

One particular example is that an early implementation of the =unique_list()=
function provided by =wirecell.jsonnet= used a /linear scan accumulator/.  Each
element of the input list was compared to every element in a growing output list
to decide if the new element should be included in the output.  Worse, this
function is used deeply in forming the final set of edges and nodes for a DFP
graph.  Its quadratic complexity did not cause problems... until it did.  The
simple but flawed algorithm was initially chosen in part because of the lack of
simple way to implement it with a hash (there is no +std.hash()+ function).  Its
current implementation makes use of the implicit hashing of Jsonnet object keys
and an explicit tracking or original order followed by a sort to reestablish that
order.  Close to a 10x speedup was achieved. 


** Use =local= to hold expensive forms

Besides the direct syntactic use of =local=, it also represents a potential point
of caching a result during Jsonnet parsing.

#+begin_src jsonnet
  {
      // avoid this
      bad: expensive_calculation(data),

      // prefer this
      local good = expensive_calculation(data),
      good: good
  }
#+end_src

** Micro optimizations

In the past, a formatted string that is deeply nested has been found to be a
significant source of compilation time.

#+begin_src jsonnet
  {
      called_frequently(data):: {
          bad: "bad_%d" % data.id,
          better: "better_" + std.toString(data.id),
      }
  }
#+end_src

** Profiling Jsonnet compilation

Unfortunately, no tools exist to perform this directly.  If that statement is
outdated, PLEASE notify me (bv at bnl dot gov).  What is left for the intrepid
optimizer is to apply time tested techniques.

- divide-and-conquer :: Select ever smaller portions of a form for compilation.  When you remove something and the compilation speeds up, you know what you removed holds forms that may be optimized.

- debug-printing :: Sprinkle your Jsonnet to wrap a =form= with =std.trace(message, form)= and observe the printed =message=.  Piping the stderr through =ts= is one easy way to get times for each printed trace.  Look for unexpectedly duplicated or numerous trace lines with suspicion.

* Meta :noexport:


#+begin_src sh :results none
scp -r pgraph.html pgraph.pdf hierocles.bnl:public_html/wire-cell/docs/
#+end_src
