#+title: WCT ~pgraph~ configuration support
#+LATEX_HEADER: \usepackage[margin=1.0in]{geometry}
#+options: ':t

* Introduction

The most popular way to construct WCT jobs is via its support for "data flow
programming" (DFP).  The "programming" here means constructing a graph with
vertices or /nodes/ representing operations on data that is transferred on /edges/.

Each node has a /component type/ (mapped to a C++ class, first argument to the
~WIRECELL_FACTORY()~ CPP macro call) and an instance name and a set number of
/input ports/ and /output ports/.  These kinds of graph are sometimes called "port
graphs" and the "p" in "pgraph" stands for "port".  Each port allows passage of
data objects of a specific interface type (a subclass of ~IData~) as determined by
the C++ node class on either end of the edge.  A valid graph has exactly one
edge between any pair of ports.

WCT is described with a simple list of component configuration objects.  Many of
these objects will configure individual nodes in the graph, but other "tool" or
"service" components are also included.  One component is special and defines
the edges of the graph in terms of ~<type>:<name>~" pair.  The ~<type>~ is the
/component type/ and the ~<name>~ is an /instance name/ to make the node unique when
multiple nodes of the same component type may exist.  If exactly one instance of
a component type exists, it can be identified with just ~<type>~.

While very simple in representation, properly forming and reasoning about
complex graphs configurations is more difficult.  To help with this, WCT
provides the ~pgraph.jsonnet~ library of functions.

* ~pgraph~ concepts

** inode

In ~pgraph.jsonnet~, a configuration object for an particular instance
of a WCT component that has an ~INode~ interface is called an *inode*.  As
introduced above an *inode* must have a ~type~ attribute and may require a
~name~ attribute.  If the WCT component is configurable (has an
~IConfigurable~ interface) then the *inode* may also have a ~data~ attribute
to supply a configuration parameters to the component instance of a
type given by ~type~.

** pnode

One very useful intermediate construction which is supported by port
graphs is that of forming a "aggregate" node from a subgraph.  This
hides arbitrary complexity of a subgraph by conceptually presenting
the whole as a single node.  Any unattached ports from any of the
subgraph nodes are assigned to the aggregate node.  A user may connect
this node into a yet larger graph without the need to understand the
internal complexity.  This abstraction can be repeated to arbitrary
scale.  That is one may construct an entire DFP graph as aggregates of
aggregates of nodes, etc.

The most important functions in ~pgraph.jsonnet~ are those that provide
ways to form various types of subgraph aggregate nodes.  For this to
work, a new type of "node" is required that can represent individual
*inode* nodes as well as aggregates of *inode* nodes.  This is called a
*pnode*.  A *pnode* is structured similarly to an *inode*.  It has a ~type~
but all *pnode* has type of ~"Pnode"~.  A *pnode* may also have an instance
~name~ with the same governing rules as for *inode*.  Additional
attributes of a *pnode* hold the subgraph information and allow
unattached ports of the subgraph to be enumerated as if their were on
the *pnode* itself.

* ~pgraph~ functions

Here describes the most important functions.  Read the code and
comments in ~pgraph.jsonnet~ for details.  In the examples, we will
assume

#+begin_src jsonnet
local pg = import "pgraph.jsonnet";
#+end_src

** Port

** Edge

** Atomic pnode

The simplest *pnode* is one that represents a single *inode*.

#+begin_src jsonnet
  local mf = {type:"MyFilter"};
  local pnode = pg.pnode(mf, nin=1, nout=1);
#+end_src

If the component has compile-time port cardinality, the ~nin~ and ~nout~
arguments *must* match expectations.  For components with dynamic port
cardinality, ~nin~ or ~nout~ will set the number to be used.

** Pipeline of pnodes

A very common subgraph pattern is a linear pipeline of nodes.  These
can be aggregated as such:

#+begin_src jsonnet
  local mf1 = {type:"MyFilter", name:"foo"};
  local mf2 = {type:"MyFilter", name:"bar"};
  local pipe = pg.pipeline([mf1,mf2]);
#+end_src

The input ports of ~mf1~ form the input ports of ~pipe~ and likewise the
output ports of ~mf2~.

** Arbitrary subgraph aggregation

An arbitrary aggregation can be formed with the ~intern()~ function.  It
accepts zero or more *pnode* objects in three collections: ~innodes~,
~centernodes~ and ~outnodes~ along with zero or more edges in ~edges~ array
and input and output ports in ~iports~ and ~oports~.  In principle, all
other *pnode* creating functions can be implemented as calls to ~intern()~
with some restriction on which of these arguments are passed.

Using the *pnode* instances created above:

#+begin_src jsonnet
  local sg = pg.intern(innodes=[pnode, pipe], outnodes=[pnode,pipe]);
#+end_src

The result would be a *pnode* with two input and two output ports taken
from those of ~pnode~ and ~pipe~.

Emulating the ~pipeline()~ function:

#+begin_src jsonnet
  local pipe2 = pg.intern(innodes=[mf1],outnodes=[mf2],
                          edges=[pg.edge(mf1,mf2)]);
#+end_src

Or a longer pipeline with three nodes

#+begin_src jsonnet
  local pipe2 = pg.intern(innodes=[mf1],centernodes=[mf],outnodes=[mf2],
                          edges=[pg.edge(mf1,mf), pf.edge(mf,mf2)]);
#+end_src

So far, the ports of the resulting *pnode* are calculated assuming all
input ports of input nodes are open and likewise for output.  The
order of these ports on the resulting *pnode* follows the order of the
nodes in their arrays and the ports in each node.

In some cases, ports may no be available for attaching or one may wish
to expose ports in a different order.  In such cases ~iports~ and ~oports~
can be explicitly given.

For example, a common subgraph pattern is an "edge tap" whereby we
wish to send to its nominal recipient as well as a new consumer.  We
must have exactly one edge per port and so we may not "split an edge".
However, there are components called "fanout" which produce a number
of parallel outputs from each input.

Here is a very contrived example:

#+begin_src jsonnet
  local fanout = pg.pnode({type:"MyFanout"}, nin=1, nout=3);
  local tapped = pg.intern(innodes=[mf], centernodes=[fanout], outnodes=[mf1,mf2],
                           edges=[pg.edge(mf,fanout),
                                  pg.edge(fanout,mf1,1,0),
                                  pg.edge(fanout,mf2,2,0)],
                           oports=[mf2.oports[0], mf1.oports[0], fanout.oports[0]]);
#+end_src

Output port 0 of the ~fanout~ is left unconnected and output port 1 of
the ~fanout~ connects to the input port of ~mf1~ and likewise for 2.  If
~oports~ were not given then the output ports of the resulting ~tapped~
*pnode* would be in order port 0 from ~[fanout,mf1,mf2]~.  For reasons
only known to the user, the reverse ordering was explicitly wanted and
given by ~oports~.

** Fans and taps

Note, ~pgraph~ provides a subobject called ~fan~ with various functions to
construct fan in/out subgraphs: ~fanout(), fanin(), pipe(), sink()~.  It
also provides the ~tap()~ function to make constructing "edge taps" as
described above simple.

** Edge insertion

** Aggregate closed component graphs

* C++ graph node classes

** C++ component configuration

The configuration in Jsonnet gets to an /instance/ of a C++ component that
inherits from ~IConfigurable~ via the method

#+begin_src c++
  void configure(const Configuration& cfg);
#+end_src

The ~Configuration~ class is a C++ object equivalent to the JSON component
configuration object described above.  The C++ ~IConfigurable~ component should
interpret the ~Configuration~ object for a set of established attributes, handle
type conversion, default values and raise exception if required values are
missing or the wrong type or have illegal value.

The ~configure()~ method is guaranteed to be called in a single-threaded context.
In most WCT jobs, ~configure()~ is called once and there is no "reconfigure".  Though, generally, class implementations should assume ~configure()~ may be called more than once.

An ~IConfigurable~ class may also provide default values with the method

#+begin_src c++
  Configuration default_configuration() const;
#+end_src

Any configuration provided by the user will be merged into this default object
by the WCT's configuration manager.  This method is also called in a
single-threaded context.

** Common C++ configuration idioms

An ~IConfigurable~ should use doxygen comments to state configuration parameters.
These comments may be placed anywhere in the class definition and often located
on attributes.  For example:

#+begin_src c++
  private:
      /// Configuration: "nticks"
      ///
      /// An integer specifying the number of samples.
      int m_nticks{6000};
#+end_src

Then in the two methods descried above:

#+begin_src c++
  Configuration MyClass::default_configuration() const {
      Configuration cfg;
      cfg["nticks"] = m_nticks;
      return cfg;
  }
  void MyClass::configure(const Configuration& cfg) {
      m_ticks = get(cfg, "nticks", m_ticks);
  }
#+end_src

** C++ graph class inheritance.

A C++ class inheriting from ~INode~ is a graph node class.  Almost all graph node
classes inherit from an interface further down the inheritance tree which
specifies the category of node (source, sink, function, fanin, fanout, etc) and
the types of data passed by nodes.  Eg an ~IFrameFilter~ node is an
~IFunction<IFrame,IFrame>~ node.  The reminder of this section describes
requirements on C++ class nodes

** Registration of a concrete component.

Every C++ node class must be registered with the WCT "named factory".  The
details of this factory are found elsewhere.  The node developer merely must add
lines in the node ~.cxx~ file like:

#+begin_src c++
  #include "WireCellUtil/NamedFactory.h"
  WIRECELL_FACTORY(<component-type-name>, <class>, <comma separated list of interfaces>)
#+end_src

For example, the "digitizer" node from the simulation is registered as:

#+begin_example
WIRECELL_FACTORY(Digitizer, WireCell::Gen::Digitizer,
                 WireCell::INamed,
                 WireCell::IFrameFilter,
                 WireCell::IConfigurable)
#+end_example

If a node class inherits from a concrete class, its interfaces must also be
listed.  For example, the ~Digitizer~ inheres from a very prolific base called
~Aux::Logger~ which is an ~INamed~.

** Callable DFP graph node operator and its return value.

Every node "executes" by a graph engine calling that nodes callable operator:

#+begin_src c++
  bool operator()(/*node type-specific arguments*/) const;
#+end_src

The arguments passed depend on the node.  Except for sources and sinks that have
a single argument, an input and an output argument are passed.  For example,
~Digitizer~ gets an input and an output ~IFrame::pointer~.  Some nodes such as
fanins and fanouts or queued-out types, get a vector argument.  Some special
nodes may have a tuple.

For all nodes except for source nodes, the boolean return value is ignored by a
graph execution engine.  For a source node it is critical to return ~false~ once
there is no more data to produce.  But, see next section about EOS.


** End-of-stream (EOS) protocol for data flow graph nodes

Every node must participate in the end-of-stream (EOS) protocol.  An EOS is used
to indicate exactly what its name says: a stream of objects has ended.  It is
conceptually modeled after NULL-terminated C strings.

An EOS marker always starts with a source node.  After the last "real" object is
output by a source node, it must send out exactly one EOS, still returning true.
If the graph engine calls the source again, and that source can not start a new
stream, then it must return ~false~.  Every other node must check for EOS on input
and forward EOS to all output.  Thus an EOS propagates through the graph.

When an EOS is encountered, the node should perform any flushing of cached data.
Often jobs will exit after an EOS completes its passage through the graph.  But,
if a source restarts a new stream then the graph will keep executing.

An EOS is always a ~nullptr~ but its placement depends on the type of argument to
the node's callable operator.

- scalar (eg, shared pointer) marks EOS as a ~nullptr~.
- vector (eg input to fanin, output to fanout) marks EOS as a vector full of ~nullptr~.
- queue (eg, Drifter) places an ~nullptr~ into its output vector, usually at the end.

Specifically, an empty vector for a fanin/fanout is illegal and something has
gone horribly wrong.  A queued-out node may have an empty vector if it simply
has not produced anything.  Asynchronous branch/merge nodes have data on just
one port so any port with EOS means EOS.

** Not-EOS

Some ~IData~ is a collection of other ~IData~.  For example, an ~IFrame~ has a vector
of ~ITrace~.  Such aggregate data types can have empty collections.  These are NOT
EOS.  If an aggregate type with an empty collection is input to a node, it still
must be processed and a valid output produced.  Typically, this means the output
likewise is in some ways "empty".


* Performance

Some Jsonnet forms can contribute to drastically large Jsonnet compilation
times.  The main cause is that Jsonnet tends to reevaluate forms that are
repeatedly used.  The Go version does a much better job of internally caching
objects than the C++ version, and WCT has moved to use it by default.  However,
surprisingly long compilation times can still be encountered.  Here are some
recommendations to avoid introducing problems.

** Avoid computational complexity

Be cautious of producing a function that scales poorly with the size of its
input.  This is a general precaution but as Jsonnet is a /purely functional/
programming language with a somewhat limited standard library it can be
particularly easy to solve a problem with a bad algorithm.  It may be fast in
testing and only show a problem as the configuration grows.

One particular example is that an early implementation of the =unique_list()=
function provided by =wirecell.jsonnet= used a /linear scan accumulator/.  Each
element of the input list was compared to every element in a growing output list
to decide if the new element should be included in the output.  Worse, this
function is used deeply in forming the final set of edges and nodes for a DFP
graph.  Its quadratic complexity did not cause problems... until it did.  The
simple but flawed algorithm was initially chosen in part because of the lack of
simple way to implement it with a hash (there is no +std.hash()+ function).  Its
current implementation makes use of the implicit hashing of Jsonnet object keys
and an explicit tracking or original order followed by a sort to reestablish that
order.  Close to a 10x speedup was achieved. 


** Use =local= to hold expensive forms

Besides the direct syntactic use of =local=, it also represents a potential point
of caching a result during Jsonnet parsing.

#+begin_src jsonnet
  {
      // avoid this
      bad: expensive_calculation(data),

      // prefer this
      local good = expensive_calculation(data),
      good: good
  }
#+end_src

** Micro optimizations

In the past, a formatted string that is deeply nested has been found to be a
significant source of compilation time.

#+begin_src jsonnet
  {
      called_frequently(data):: {
          bad: "bad_%d" % data.id,
          better: "better_" + std.toString(data.id),
      }
  }
#+end_src

** Profiling Jsonnet compilation

Unfortunately, no tools exist to perform this directly.  If that statement is
outdated, PLEASE notify me (bv at bnl dot gov).  What is left for the intrepid
optimizer is to apply time tested techniques.

- divide-and-conquer :: Select ever smaller portions of a form for compilation.  When you remove something and the compilation speeds up, you know what you removed holds forms that may be optimized.

- debug-printing :: Sprinkle your Jsonnet to wrap a =form= with =std.trace(message, form)= and observe the printed =message=.  Piping the stderr through =ts= is one easy way to get times for each printed trace.  Look for unexpectedly duplicated or numerous trace lines with suspicion.

* Meta :noexport:


#+begin_src sh :results none
scp -r pgraph.html pgraph.pdf hierocles.bnl:public_html/wire-cell/docs/
#+end_src
