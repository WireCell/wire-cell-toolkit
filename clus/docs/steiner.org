#+title: Info related to porting of Steiner-related WCP code

* Links

- Meta issue https://github.com/WireCell/wire-cell-toolkit/issues/431

* Guidance

** Code organization

- All Steiner-related header and source code is in ~clus/src/~ and so is "private" to the sub-package.

- All Steiner-related code is in the ~WireCell::Clus::Steiner::~ namespace.

- ~CreateSteinerGraph~ in ~CreateSteinerGraph.{h,cxx}~ is the "ensemble visitor" that is to be added to an MABC pipeline.

- ~Steiner::Grapher~ in ~SteinerGrapher.{h,cxx}~ is a class that "wraps" one ~Cluster~.  It is kind of a "facade of a facade".  This class is intended to represent the Steiner-related parts of ~PR3DCluster~.  As such it is okay to load it up with whatever per-Cluster auxiliary information and methods that are needed.  It is also given a ~Config~ struct that holds any required "service" components (eg, sampler, detector volumes).  The main duty of the ~Grapher~ is to return a graph from its ~create_steiner_graph()~ method.  The ~CreateSteinerGraph::visit()~ is responsible to make a ~Grapher~, call it and dispatch the resulting graph.

* Developing

Xin, I think you will hack mostly on ~SteinerGrapher.{h,cxx}~ and
~SteinerFunctions.{h,cxx}~.  Feel free to fill these up.  In particular, the
arguments to the existing methods and functions are definitely incomplete.  If
these ~Steiner*.{h,cxx}~ files become uncomfortably large, feel free to make more
~.cxx~ files.  Specifically do not add more ~.h~ files that have actual code as was
done in WCP.  

Please come back to me whenever something has no obvious solution or if if you
feel something needs to be added to the outer layers (eg ~CreateSteinerGraph~ or
outside ~clus/~).


* Howtos

** Graphs on a Cluster

~Cluster~ can hold graphs in a generic way by a *name*.  See the ~Graphs~ base class
in [[file:../inc/WireCellClus/Facade_Mixins.h]].  You may construct a graph outside
of ~Cluster~ and give it to ~Cluster~ by name and later retrieve it by name.

~Cluster~ also yields ~GraphAlgorithms~ by calling one of the variants of the
~Cluster::graph_algorithms()~ methods.  The underlying graph will be constructed
if it does not yet exist.  It uses *reserved names*:

- basic :: equivalent to WCP's ~Create_graph()~ with no args.
- ctpc :: the graph used by  WCP's (and WCT's) Dijikstra's shortests paths. 
- relaxed :: the graph used by WCP's examine graph (WCT's connected blobs).

After creating one of these graphs by calling ~Cluster::graph_algorithms()~ you
can also get the underlying graph by name.  Likewise, if you set a graph with a
reserved name and then later call ~Cluster::graph_algorithms()~, it will use your
graph.  Otherwise, you are free to add and retrieve graphs with any name you
like.

Graphs are merely held by the ~Cluster~ and are not part of the ~Cluster~ cache.
There is no (or not yet any) explicit connection between a graph and an
associated point cloud.  For now, it is up to the user to coordinate that
association.


** Graph reduction

A graph can be "filtered" or "reduced" to make a subgraph in two basic ways.

*** Manual

The more labor-intensive way is for user code to create a new, empty graph, loop
over an existing graph and manually fill the new one with whatever vertices
and/or edges desired.

When the new graph has a subset of vertices, their descriptors (indices) will
not match (in general) the corresponding vertices from the original graph.

*** Filtered graph

A Boost filtered graph is a graph-like "view" on an original graph that is
generated by specifying a *predicate* (true/false method) to select vertices
and/or edges.

As it is only a "view" the original graph must be kept alive and the filtered
graph vertices exactly match their corresponding vertices in the original.

A filtered graph can be converted in to a "real" graph with:

#+begin_src c++
  filtered_graph_type view = my_filter(graph);
  graph_type reduced;
  boost::copy_graph(view, reduced);
#+end_src

The "real" graph can live beyond the original ~graph~ and its vertex descriptors
(indices) have consecutive values that have lost any correspondence with the
original.

*** Support

The ~Weighted::GraphAlgorithms~ class provides methods ~reduce()~ to return a
filtered graph given a set of vertices or edges to accept/reject.  It also
provides ~weight_threshold()~ to accept/reject edges based on comparing their edge
weights to a give threshold value.



** Making a fresh Cluster

There are cases in WCP where a ~PR3DCluster~ must be made from scratch.  In WCT, a
~Cluster~ is a facade over an underlying node (and a ~Grapher~ is yet another
layer).  It is the node that is memory managed and owns the facade.  We thus
must keep the node alive while we use its ~Cluster~ (or its ~Grapher~).  For an
isolated case (no parent ~Grouping~) we may do:

#+begin_src c++
  Points::node_t new_cluster_node;
  Cluster& new_cluster = new_cluster_node.value.facade<Cluster>();
#+end_src

Everything is destroyed when ~new_cluster_node~ goes out of scope.  Alternatively,
if we want to make the new ~Cluster~ on an existing ~GRouping~ we can do:

#+begin_src c++
  Grouping& grouping;             // we get somehwere
  Cluster& cluster = grouping.make_child();
#+end_src



* PAAL

WCP interned a copy of all of PAAL but only used a tiny portion:

#+begin_src c++
  struct less{};
  class nearest_recorder;
  nearest_recorder make_nearest_recorder();
#+end_src

These bits are copied into ~clus/src/PAAL.h~.  The ~SteinerGrapher_fake.cxx~
includes some code to exercise compiling this code.
